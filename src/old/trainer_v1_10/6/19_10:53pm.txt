import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.Buffer;
import java.util.StringTokenizer;

public class Trainer
{
   Perceptron perceptron;
   String[] inputFiles;
   static double MINIMUM_ERROR;
   double lambda;
   double totalError;
   double previousTotalError;
   double[][][] trainedWeights;
   double[][][] experimentalWeights;


   /**
    * Creates a new trainer for a perceptron, with a list of input filenames.
    *
    * @param inputFiles The list of input file names. Must be a full path.
    */
   public Trainer(String[] inputFiles)
   {
      this.inputFiles = inputFiles;
      this.totalError = 10.0;                                                            // Total and Previous Total errors start
      this.previousTotalError = 0.0;                                                    // as 0.0.
      this.lambda = 0.1;

      perceptron = new Perceptron(2, new int[]{2}, 1, inputFiles[0]);

      this.trainedWeights = new double[perceptron.weights.length]            // Create the currentWeights, copying the
                                      [perceptron.weights[0].length]         // values from the perceptron's set of
                                      [perceptron.weights[0][0].length];     // weights the first time.

      for (int i = 0; i < perceptron.weights.length; i++)
      {
         for (int j = 0; j < perceptron.weights[0].length; j++)
         {
            for (int k = 0; k < perceptron.weights[0][0].length; k++)
            {
               this.trainedWeights[i][j][k] = 1.0 * (Math.random());
            }
         }
      }

      this.experimentalWeights = new double[perceptron.weights.length]
                                      [perceptron.weights[0].length]
                                      [perceptron.weights[0][0].length];
      for (int i = 0; i < perceptron.weights.length; i++)
      {
         for (int j = 0; j < perceptron.weights[0].length; j++)
         {
            for (int k = 0; k < perceptron.weights[0][0].length; k++)
            {
               this.experimentalWeights[i][j][k] = this.trainedWeights[i][j][k];
            }
         }
      }
      System.out.println("debug");           //TODO: REMOVE
   }

  /*public void determineInputs(String inputFile)
   {
      BufferedReader bufferedReader;
      StringTokenizer stringTokenizer;

      try
      {
         bufferedReader = new BufferedReader(new FileReader(inputFileName));
         stringTokenizer = new StringTokenizer(bufferedReader.readLine());
      }
      catch (IOException e)
      {
         throw new IllegalArgumentException("Input " + e.toString() + " not accepted, terminating.");
      }

      // Iterate over the inputs in the first line then populate the input activation array
      for (int i = 0; i < inputs.length; i++)
      {
         inputs[i] = Double.parseDouble(stringTokenizer.nextToken());
      }

      try
      {
         // Advance the Buffered Reader by one line to begin reading the weights
         stringTokenizer = new StringTokenizer(bufferedReader.readLine());
      }
      catch (IOException e)
      {
         throw new IllegalArgumentException("Input " + e.toString() + " incorrectly shows weight, terminating.");
      }

      // Iterate over the 3D array and populate it with the weights as written in the weights file
      for (int i = 0; i < weights.length; i++)
      {
         for (int j = 0; j < weights[i].length; j++)
         {
            for (int k = 0; k < weights[i][j].length; k++)
            {
               weights[i][j][k] = Double.parseDouble(stringTokenizer.nextToken());
            }
         }
      }

      try
      {
         // Advance the Buffered Reader by one line to begin reading the expected outputs
         stringTokenizer = new StringTokenizer(bufferedReader.readLine());
      }
      catch (IOException e)
      {
         throw new IllegalArgumentException("Input " + e.toString() + " incorrectly shows expected output, terminating.");
      }
      for (int i = 0; i < outputNodes; i++)
      {
         expectedOutputs[i] = Double.parseDouble(stringTokenizer.nextToken());
      }
   }*/

   /**
    * @param args
    */
   public static void main(String[] args)
   {
      Trainer trainer = new Trainer(new String[]{
            "/Users/mihir/IdeaProjects/Neural Networks/Java XOR Implementation/src/inputs/inputFile00.txt",
            "/Users/mihir/IdeaProjects/Neural Networks/Java XOR Implementation/src/inputs/inputFile01.txt",
            "/Users/mihir/IdeaProjects/Neural Networks/Java XOR Implementation/src/inputs/inputFile10.txt",
            "/Users/mihir/IdeaProjects/Neural Networks/Java XOR Implementation/src/inputs/inputFile11.txt"});

      trainer.train();

   }

   /**
    * Function train makes steps and modifies the perceptron's weights using gradient descent until one of two conditions are met:
    * 1. The error is the exact same as the error from the previous trial, or
    * 2. The error is less than a minimum error.
    * Only randomizes the perceptron's weights the first time, after that it does not.
    */
   void train()
   {
      int counter = 0;
      while (totalError > 0.01 && totalError != previousTotalError && counter < 100)
      {
         for (int i = 0; i < inputFiles.length; i++)
         {
            counter++;
            step();
            perceptron = new Perceptron(2, new int[]{2}, 1, inputFiles[i]);
            perceptron.readInput(new double[]{1.0});
            perceptron.runNetwork();
            perceptron.printResult();
         }
      }
   }

   /**
    * Function step runs an individual step in the training process. A step is defined as finding the partials, using the error
    * to update the weights of the perceptron,
    */
   public void step()
   {
         findTotalError();
         findPartials();
         perceptron.setWeights(this.trainedWeights);
         adaptLambda();
         updateWeights();
   }


   /**
    * Finds the total error of the function and updates the previous error.
    */
   public void findTotalError()
   {
      System.out.println(previousTotalError);
      previousTotalError = totalError;
      double error = 0.0;
      for (int i = 0; i < perceptron.outputNodes; i++)
      {
         error += 0.5 * ((perceptron.expectedOutputs[i] - perceptron.activations[i][perceptron.activations[0].length - 1]) *
               (perceptron.expectedOutputs[i] - perceptron.activations[i][perceptron.activations[0].length - 1]));
      }
      totalError = Math.sqrt(error);
      System.out.println(totalError);
   }

   /**
    * Find the partial derivatives for the gradient descent, then add them to the trial set of weights.
    */
   public void findPartials()
   {
      double sumHColumn = 0.0;
      double outputResult = perceptron.activations[0][perceptron.activations[0].length - 1];
      double error = perceptron.expectedOutputs[0] - outputResult;

      for (int j = 0; j < perceptron.inputs.length; j++)                                        // For one training case.
      {
         for (int J = 0; J < perceptron.activations[0].length - 1; J++)
         {
            sumHColumn += perceptron.activations[J][1] * perceptron.weights[1][J][0];
         }

         double finalDeriv = -perceptron.fDeriv(sumHColumn) * error * perceptron.activations[j][1];   // Partial for W_{j0}
         trainedWeights[1][j][0] += -lambda * finalDeriv;
      }

      for (int k = 0; k < perceptron.NUM_COLUMNS; k++)
      {
         for (int j = 0; j < perceptron.NUM_COLUMNS; j++)
         {
            double sumAColumn = 0;
            for (int K = 0; K < perceptron.activations.length; K++)
            {
               sumAColumn += perceptron.activations[K][0] * perceptron.weights[0][K][j];
            }

            double finalDeriv =
                  -perceptron.activations[k][0] * perceptron.fDeriv(sumAColumn) * error * perceptron.fDeriv(sumHColumn) *
                        perceptron.weights[0][k][j];

            trainedWeights[0][k][j] += -lambda * finalDeriv;
         }
      }
   }

   /**
    * Function adaptLambda
                                                                                                                                                                                                                                                                                                                                                          *
    */
   public void adaptLambda()
   {
      return;
      /*if(totalError < previousTotalError)
      {
         lambda *= 2.0;
         updateWeights();
      }
      else
      {
         lambda /= 2.0;
      }*/
   }

   public void updateWeights()
   {
      for (int i = 0; i < experimentalWeights.length; i++)
      {
         for (int j = 0; j < experimentalWeights[0].length; j++)
         {
            for (int k = 0; k < experimentalWeights[0][0].length; k++)
            {
               experimentalWeights[i][j][k] = trainedWeights[i][j][k];
            }
         }
      }
   }
}
